def sdkPath(String platform) {
    return "/Applications/Xcode.app/Contents/Developer/Platforms/${platform}.platform/Developer/SDKs/${platform}${IOS_VERSION}.sdk";
}

ext.explodeAarDependencies = {project, configuration ->
    Set<File> files = configuration.copy().resolve()
    files.findAll {
        it.name.endsWith('.aar')
    }.each { aarFile ->
        def aarFileWithoutExtension = aarFile.name.take(aarFile.name.lastIndexOf('.'))
        final File explodedDirectory = new File(aarFile.parent, "exploded")
        if (!explodedDirectory.exists()) {
            project.logger.info("Explode aar file: $aarFile into $explodedDirectory")

            if (!explodedDirectory.mkdirs()) {
                throw new GradleException("Unable to create base directory to explode aar into: " + explodedDirectory)
            }

            project.copy {
                from project.zipTree(aarFile)
                into project.file(explodedDirectory)
                include 'classes.jar'
                include 'libs/*.jar'
                rename('classes.jar', "${aarFileWithoutExtension}.jar")
            }
        }

        if (project.file("$explodedDirectory.absolutePath/${aarFileWithoutExtension}.jar").exists()) {
            project.dependencies.add(configuration.name, project.files("$explodedDirectory.absolutePath/${aarFileWithoutExtension}.jar"))
        }
        if (project.file("$explodedDirectory.absolutePath/libs").exists()) {
            project.files(project.file("$explodedDirectory.absolutePath/libs").listFiles()).findAll {
                it.name.endsWith('.jar')
            }.each {
                project.dependencies.add(configuration.name, project.files(it))
            }
        }
    }
}

ext.nativeBuild = { project, name, os ->

    println("native build for ${name} started")
    File shareDir = file("${project.projectDir}/src/main/native/share")
    if (!shareDir.exists()) {
        // TODO
        //println("No share lib dir found for ${name}")
        //return
    }
    def sharedSources = shareDir.listFiles()

    def osSources = []
    File osDir = file("${project.projectDir}/src/main/native/${os}")
    if (osDir.exists()) {
        osSources = osDir.listFiles()
    } else {
        println("No native lib dir found for ${name} at ${osDir}")
        return
    }

    def JAVAHOME = System.getenv("JAVA_HOME")
    def includeFlags = [
            "-I${JAVAHOME}/include",
            "-I${project.projectDir}/../../gradle/include",
    ]
    def osIncludeFlags = ""

    if (os == "ios") {
        osIncludeFlags = "-I${JAVAHOME}/include/darwin"

        def linkerOutputs = []
        def lipoOutput = "${project.buildDir}/native/ios/lib${name}.a"

        def buildSystems = ["iPhoneOS+arm64", "iPhoneSimulator+x86_64"]
        buildSystems.each { buildSystem ->

            def (platform, arch) = buildSystem.tokenize("+")
            if (!file(sdkPath(platform)).exists()) {
                println "Skipping native-build on iOS: path for ${platform} doesn't exist"
                return
            }
            
            osSources = "${project.projectDir}/src/main/native/${os}/${name}.m"
            
            def compileOutput = "${project.buildDir}/native/ios/${arch}"
            new File(compileOutput).mkdirs()
            def compileOutputs = ["${project.buildDir}/native/ios/${arch}/${name}.o"]
            def linkerOutput = "${project.buildDir}/native/ios/${arch}/lib${name}.a"
            
            def clangArgs = [
                "-xobjective-c",
                "-mios-version-min=11.0",
                includeFlags,
                osIncludeFlags,
                "-c",
                "-fPIC",
                "-arch", arch,
                "-isysroot",
                sdkPath(platform),
                osSources].flatten()

            exec {
                executable "clang"
                args clangArgs
                workingDir compileOutput
            }

            def linkerArgs = [
                    "-static",
                    "-framework", "Foundation",
                    "-framework", "CoreGraphics",
                    "-framework", "CoreBluetooth",
                    "-framework", "CoreLocation",
                    "-framework", "CoreMotion",
                    "-framework", "CoreText",
                    "-framework", "UIKit",
                    "-framework", "QuartzCore",
                    "-framework", "OpenGLES",
                    "-framework", "StoreKit",
                    "-framework", "UserNotifications",
                    "-arch_only", arch,
                    "-syslibroot", sdkPath(platform),
                    "-L${sdkPath(platform)}/usr/lib",
                    "-o", linkerOutput,
                    compileOutputs
            ].flatten()

            exec {
                executable "libtool"
                args linkerArgs
                workingDir compileOutput
            }
            linkerOutputs.add(linkerOutput)
        }

        // execute lipo to combine all linker output in one archive
        def lipoArgs = ["-create", linkerOutputs, "-o", lipoOutput].flatten()
        exec {
            executable "lipo"
            args lipoArgs
        }

        println("native build for ${name} finished")
        File n = new File(lipoOutput)
        if (n.exists()) {
            println "Adding ${n} to native jar"
            n
        }
    } else if (os == "android") {
        def sdk = System.getenv("ANDROID_SDK")
        if (sdk == null) {
            throw new GradleException("Error: ANDROID_SDK can't be null")
        }
        def androidJar = sdk + "/platforms/android-27/android.jar"

        def ndk = System.getenv("ANDROID_NDK")
        if (ndk == null) {
            throw new GradleException("Error: ANDROID_NDK can't be null")
        }
        def host = System.getProperty('os.name').toLowerCase().contains("mac") ?
                "darwin" : "linux"

        def arch = "arm64-v8a"
        def compileOutput = "${project.buildDir}/native/${os}/${arch}"
        def linkerObj = "${project.buildDir}/native/${os}/${arch}/${name}.o"
        def linkerOutput = "${project.buildDir}/native/${os}/lib${name}.a"
        new File(compileOutput).mkdirs()

        def platform="aarch64-linux-android21"
        def toolchainHome = "${ndk}/toolchains/llvm"
        def compilerHome = "${toolchainHome}/prebuilt/${host}-x86_64"
        def compiler = file("${compilerHome}/bin/clang").getAbsolutePath()
        def linker = file("${compilerHome}/bin/llvm-ar").getAbsolutePath()

        osIncludeFlags = ["-I${JAVAHOME}/include/${host}",
                          "-I${project.projectDir}/../../gradle/include/android",
                          "-I${project.projectDir}/../util/src/main/native/${os}/c"].flatten()

        def dalvikOutput = "${project.buildDir}/resources/main/META-INF/substrate/dalvik/precompiled/classes"
        file(dalvikOutput).mkdirs()
        File sourcesDir = file("${project.projectDir}/src/main/native/${os}/dalvik")
        File sourcesUtilDir = file("${project.projectDir}/../util/src/main/native/${os}/dalvik")
        if (sourcesDir.exists()) {
            def javaSources = [sourcesDir.listFiles(),
                               sourcesUtilDir.listFiles()].flatten()

            def javacArgs = ["-d", dalvikOutput,
                             "-source", "1.7", "-target", "1.7",
                             "-bootclasspath", androidJar,
                             javaSources].flatten()

            if (project.configurations.find { it.name == 'dalvik' }) {
                javacArgs += [ "-classpath", project.configurations.dalvik.asPath ]
            }

            exec {
                executable "javac"
                args javacArgs
                workingDir sourcesDir
            }
        }
        File nativeSourcesDir = file("${project.projectDir}/src/main/native/${os}/c/")
        osSources = [nativeSourcesDir.listFiles().findAll {it.name.endsWith(".c")}].flatten()

        def compilerArgs = ["-target", platform, "-c", includeFlags, osIncludeFlags, osSources].flatten()

        exec {
            executable compiler
            args compilerArgs
            workingDir compileOutput
        }

        def linkerArgs = ["rcs", linkerOutput, linkerObj].flatten()

        exec {
            executable linker
            args linkerArgs
        }

        println("native build for ${name} finished")
        File a = new File(linkerOutput)
        if (a.exists()) {
            println "Adding ${a} to native jar"
            a
        }
    } else {
        // TODO
        def compileOutput = "${project.buildDir}/native/${os}"
        new File(compileOutput).mkdirs()

        def compiler = "gcc"

        def cargs = [
                "-c", includeFlags, osIncludeFlags, sharedSources, osSources
        ].flatten()

        exec {
            executable "/usr/bin/gcc"
            args cargs
            workingDir compileOutput
        }
        // TODO
        File n = new File("${project.buildDir}/native/${os}")
        if (n.exists()) {
            println "Adding lib${name} to native jar"
            fileTree("${project.buildDir}/native/${os}").filter { it.isFile() }.files
                    .first()
        }
    }
}